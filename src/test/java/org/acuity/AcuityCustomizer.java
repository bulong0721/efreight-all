package org.acuity;

import java.math.BigDecimal;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Properties;

import org.apache.openjpa.enhance.ApplicationIdTool;
import org.apache.openjpa.jdbc.meta.ClassMapping;
import org.apache.openjpa.jdbc.meta.FieldMapping;
import org.apache.openjpa.jdbc.meta.ReverseCustomizer;
import org.apache.openjpa.jdbc.meta.ReverseMappingTool;
import org.apache.openjpa.jdbc.schema.Column;
import org.apache.openjpa.jdbc.schema.ForeignKey;
import org.apache.openjpa.jdbc.schema.Table;
import org.apache.openjpa.lib.util.CodeFormat;

public class AcuityCustomizer implements ReverseCustomizer {

    private Map<String, Sequence> seqMap = getSequenceFromDB();
    private ReverseMappingTool    tool;
    public int                    count;

    @Override
    public void setConfiguration(Properties props) {
    }

    @Override
    public void setTool(ReverseMappingTool tool) {
        this.tool = tool;
    }

    @Override
    public int getTableType(Table table, int defaultType) {
        return defaultType;
    }

    @Override
    public String getClassName(Table table, String defaultName) {
        return defaultName;
    }

    @Override
    public void customize(ClassMapping cls) {

    }

    @Override
    public String getClassCode(ClassMapping mapping) {
        CodeFormat code = new CodeFormat();
        code.append("${packageDec}").afterSection();
        code.append("${imports}").afterSection();

        code.append("/**").endl().append(" * Auto-generated by:").endl().append(" * ").append(getClass().getName()).endl().append(" */").endl();

        writeAnnotations(code, tool.getAnnotationsForMeta(mapping), 0);
        code.append("public class ").append("${className}");
        code.extendsDec(1).append(" ").append("com.acuity.common.EntityBase");
        code.openBrace(1).endl();
        code.tab().append("private static final long serialVersionUID = 1L;").endl();
        code.append("${fieldDecs}").afterSection();

        // default constructor
        code.tab().append("public ").append("${className}").parens();
        code.openBrace(2).endl().closeBrace(2);

        code.afterSection().append("${constructor}");
        code.afterSection().append("${fieldCode}");
        code.endl();
        closeClassBrace(code, null);

        return code.toString();
    }

    private void closeClassBrace(CodeFormat code, ApplicationIdTool _appid) {
        if (_appid != null) {
            code.afterSection();
            code.append(_appid.getCode());
            code.endl();
        }
        code.closeBrace(1);
    }

    static class Sequence {

        public int           id;
        public boolean       isTabelId;
        public String        name;
        public int           increment;
        private List<String> keyAnnotation;

        public Sequence(int id, String table, int increment, boolean isTableId){
            this.id = id;
            this.name = table;
            this.increment = increment;
            this.isTabelId = isTableId;
        }

        public List<String> getKeyAnnotation() {
            if (null == keyAnnotation) {
                keyAnnotation = new ArrayList<String>();
                StringBuffer buffer = new StringBuffer();
                String pkGen = "PkGen_" + id;
                String where = getWhere();
                buffer.append("@TableGenerator(name = \"").append(pkGen).append("\", table = \"c_sequence\", pkColumnName = \"name\", pkColumnValue = \"").append(where).append("\", valueColumnName = \"currentnextsys\", allocationSize = ").append(increment).append(" )");
                keyAnnotation.add(buffer.toString());
                buffer.setLength(0);
                buffer.append("@GeneratedValue(strategy = GenerationType.TABLE, generator = \"").append(pkGen).append("\")");
                keyAnnotation.add(buffer.toString());
                buffer.setLength(0);
            }
            return keyAnnotation;
        }

        public String getWhere() {
            return name;
        }
    }

    @SuppressWarnings("deprecation")
    public Sequence getSequence(FieldMapping field) {
        String table = field.getTable().getName();
        String column = field.getColumns()[0].getName();
        String key = (table + "." + column).toUpperCase();
        return seqMap.get(key);
    }

    private Map<String, Sequence> getSequenceFromDB() {
        Map<String, Sequence> result = new HashMap<String, Sequence>(1200);
        try {
            Class.forName("com.mysql.jdbc.Driver");
            Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/acuity", "adempiere", "adempiere");
            PreparedStatement stm = conn.prepareStatement("SELECT C_SEQUENCE_ID, NAME, INCREMENTNO, ISTABLEID  FROM c_sequence");
            ResultSet rs = stm.executeQuery();
            while (rs.next()) {
                int id = rs.getInt(1);
                String table = rs.getString(2);
                int increment = rs.getInt(3);
                boolean isTableId = rs.getBoolean(4);
                Sequence seq = new Sequence(id, table, increment, isTableId);
                if (isTableId) {
                    result.put((table + "." + table + "_ID").toUpperCase(), seq);
                } else {
                    result.put(table, seq);
                }
            }
            rs.close();
            stm.close();
            conn.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return result;
    }

    @SuppressWarnings("rawtypes")
    private void writeAnnotations(CodeFormat code, List ann, int tabLevel) {
        if (ann == null || ann.size() == 0) return;
        for (Iterator i = ann.iterator(); i.hasNext();) {
            if (tabLevel > 0) code.tab(tabLevel);
            String s = (String) i.next();
            code.append(s).endl();
        }
    }

    @Override
    public String getFieldName(ClassMapping dec, Column[] cols, ForeignKey fk, String defaultName) {
        return defaultName;
    }

    @Override
    public void customize(FieldMapping field) {
        Class<?> declaredType = field.getDeclaredType();
        String typeName = declaredType.getSimpleName();
        if ("long".equalsIgnoreCase(typeName)) {
            Column column = field.getColumns()[0];
            if (column.getSize() > 10) {
                field.setDeclaredType(Long.class);
            } else {
                field.setDeclaredType(Integer.class);
            }
        } else if ("double".equalsIgnoreCase(typeName)) {
            field.setDeclaredType(BigDecimal.class);
        } else if ("float".equalsIgnoreCase(typeName)) {
            field.setDeclaredType(BigDecimal.class);
        } else if ("boolean".equalsIgnoreCase(typeName)) {
            field.setDeclaredType(Boolean.class);
        } else if ("char".equalsIgnoreCase(typeName)) {
            field.setDeclaredType(String.class);
        } else if ("int".equalsIgnoreCase(typeName)) {
            field.setDeclaredType(Integer.class);
        }
    }

    @Override
    public String getInitialValue(FieldMapping field) {
        return null;
    }

    @Override
    public String getDeclaration(FieldMapping field) {
        return null;
    }

    @SuppressWarnings({ "rawtypes", "unchecked" })
    @Override
    public String getFieldCode(FieldMapping field) {
        if (field.isPrimaryKey()) {
            Sequence seq = getSequence(field);
            if (null != seq) {
                List meta = tool.getAnnotationsForMeta(field);
                for (String ann : seq.getKeyAnnotation()) {
                    meta.add(ann);
                }
            }
        }
        return null;
    }

    @Override
    public boolean unmappedTable(Table table) {
        return false;
    }

    @Override
    public void close() {
    }

}
